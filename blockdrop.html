<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Drop</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #111;
            color: white;
            touch-action: none;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 20px;
        }

        #gameInfo {
            display: flex;
            gap: 30px;
            font-size: 18px;
        }

        #mainCanvas {
            border: 2px solid #444;
            background-color: #000;
            touch-action: none;
        }

        #nextPiecesCanvas {
            border: 2px solid #444;
            background-color: #000;
        }

        .info-section {
            text-align: center;
        }

        .info-section span {
            display: block;
            margin-top: 5px;
            font-size: 24px;
            font-weight: bold;
        }

        #controls {
            text-align: center;
            font-size: 14px;
            opacity: 0.7;
        }

        @media (max-width: 600px) {
            #gameInfo {
                font-size: 16px;
            }
            
            .info-section span {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="gameInfo">
            <div class="info-section">
                Score: <span id="score">0</span>
            </div>
            <div class="info-section">
                Level: <span id="level">1</span>
            </div>
            <div class="info-section">
                Lines: <span id="lines">0</span>
            </div>
        </div>
        
        <div style="display: flex; gap: 20px; align-items: flex-start;">
            <canvas id="mainCanvas"></canvas>
            <div>
                <div style="margin-bottom: 10px;">Next:</div>
                <canvas id="nextPiecesCanvas"></canvas>
            </div>
        </div>
        
        <div id="controls">
            Touch: Tap=Rotate | Swipe=Move | Swipe Down=Soft Drop | Swipe Up/Double Tap=Hard Drop<br>
            Keys: ←→=Move | ↑=Rotate | ↓=Soft Drop | Space=Hard Drop
        </div>
    </div>

    <script>
        // Constants
        const COLS = 10;
        const ROWS = 24;
        const BLOCK_SIZE = 30;
        const LINES_PER_LEVEL = 20;
        
        // Colors for pieces
        const COLORS = {
            I: '#00f0f0',
            T: '#a000f0',
            L: '#f0a000',
            J: '#0000f0',
            S: '#00f000',
            Z: '#f00000',
            shortL: '#f0f000',
            shortJ: '#f000f0',
            empty: '#000'
        };

        // Piece definitions
        const PIECES = {
            I: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
            T: [[0,1,0], [1,1,1], [0,0,0]],
            L: [[0,0,1], [1,1,1], [0,0,0]],
            J: [[1,0,0], [1,1,1], [0,0,0]],
            S: [[0,1,1], [1,1,0], [0,0,0]],
            Z: [[1,1,0], [0,1,1], [0,0,0]],
            shortL: [[1,0], [1,1]],
            shortJ: [[1,1], [1,0]]
        };

        // Drop weights
        const DROP_WEIGHTS = {
            I: 0.1, T: 0.1, L: 0.1, J: 0.1, S: 0.1, Z: 0.1,
            shortL: 0.2, shortJ: 0.2
        };

        // Tetromino class
        class Tetromino {
            constructor(type, x = Math.floor(COLS / 2) - 1, y = 0) {
                this.type = type;
                this.shape = PIECES[type];
                this.color = COLORS[type];
                this.x = x;
                this.y = y;
            }

            rotate() {
                const n = this.shape.length;
                const rotated = Array(n).fill().map(() => Array(n).fill(0));
                
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        rotated[i][j] = this.shape[n - 1 - j][i];
                    }
                }
                
                return rotated;
            }

            getBlocks() {
                const blocks = [];
                for (let y = 0; y < this.shape.length; y++) {
                    for (let x = 0; x < this.shape[y].length; x++) {
                        if (this.shape[y][x]) {
                            blocks.push({x: this.x + x, y: this.y + y});
                        }
                    }
                }
                return blocks;
            }
        }

        // GameBoard class
        class GameBoard {
            constructor() {
                this.grid = Array(ROWS).fill().map(() => Array(COLS).fill(0));
                this.currentPiece = null;
                this.nextPieces = [];
                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.gameOver = false;
                
                // Generate initial pieces
                this.generateNextPieces();
                this.spawnPiece();
            }

            generateNextPieces() {
                while (this.nextPieces.length < 2) {
                    this.nextPieces.push(this.getRandomPieceType());
                }
            }

            getRandomPieceType() {
                const random = Math.random();
                let cumulative = 0;
                
                for (const [type, weight] of Object.entries(DROP_WEIGHTS)) {
                    cumulative += weight;
                    if (random < cumulative) {
                        return type;
                    }
                }
                
                return 'I'; // Fallback
            }

            spawnPiece() {
                const type = this.nextPieces.shift();
                this.generateNextPieces();
                
                this.currentPiece = new Tetromino(type);
                
                if (!this.isValidPosition(this.currentPiece)) {
                    this.gameOver = true;
                }
            }

            isValidPosition(piece, offsetX = 0, offsetY = 0) {
                const blocks = piece.getBlocks();
                
                for (const block of blocks) {
                    const newX = block.x + offsetX;
                    const newY = block.y + offsetY;
                    
                    if (newX < 0 || newX >= COLS || newY >= ROWS) {
                        return false;
                    }
                    
                    if (newY >= 0 && this.grid[newY][newX]) {
                        return false;
                    }
                }
                
                return true;
            }

            movePiece(dx, dy) {
                if (!this.currentPiece) return false;
                
                if (this.isValidPosition(this.currentPiece, dx, dy)) {
                    this.currentPiece.x += dx;
                    this.currentPiece.y += dy;
                    return true;
                }
                
                return false;
            }

            rotatePiece() {
                if (!this.currentPiece) return false;
                
                const originalShape = this.currentPiece.shape;
                this.currentPiece.shape = this.currentPiece.rotate();
                
                // Try normal rotation
                if (this.isValidPosition(this.currentPiece)) {
                    return true;
                }
                
                // Wall kick attempts
                const kicks = [[-1, 0], [1, 0], [0, -1], [-1, -1], [1, -1]];
                
                for (const [dx, dy] of kicks) {
                    if (this.isValidPosition(this.currentPiece, dx, dy)) {
                        this.currentPiece.x += dx;
                        this.currentPiece.y += dy;
                        return true;
                    }
                }
                
                // Rotation failed
                this.currentPiece.shape = originalShape;
                return false;
            }

            dropPiece() {
                if (!this.currentPiece) return false;
                
                if (this.movePiece(0, 1)) {
                    return true;
                }
                
                // Lock piece
                this.lockPiece();
                return false;
            }

            hardDrop() {
                if (!this.currentPiece) return;
                
                while (this.movePiece(0, 1)) {
                    this.score += 2;
                }
                
                this.lockPiece();
            }

            lockPiece() {
                const blocks = this.currentPiece.getBlocks();
                
                for (const block of blocks) {
                    if (block.y >= 0) {
                        this.grid[block.y][block.x] = this.currentPiece.type;
                    }
                }
                
                this.clearLines();
                this.spawnPiece();
            }

            clearLines() {
                let linesCleared = 0;
                
                for (let y = ROWS - 1; y >= 0; y--) {
                    if (this.grid[y].every(cell => cell !== 0)) {
                        this.grid.splice(y, 1);
                        this.grid.unshift(Array(COLS).fill(0));
                        linesCleared++;
                        y++; // Check same row again
                    }
                }
                
                if (linesCleared > 0) {
                    this.lines += linesCleared;
                    this.level = Math.floor(this.lines / LINES_PER_LEVEL) + 1;
                    
                    // Scoring
                    const scoreMap = [0, 100, 300, 500, 800];
                    this.score += scoreMap[Math.min(linesCleared, 4)] * this.level;
                }
            }

            getDropSpeed() {
                return Math.max(50, 1000 - (this.level - 1) * 100);
            }
        }

        // Renderer class
        class Renderer {
            constructor(mainCanvas, nextCanvas) {
                this.mainCtx = mainCanvas.getContext('2d');
                this.nextCtx = nextCanvas.getContext('2d');
                
                mainCanvas.width = COLS * BLOCK_SIZE;
                mainCanvas.height = ROWS * BLOCK_SIZE;
                
                nextCanvas.width = 4 * BLOCK_SIZE;
                nextCanvas.height = 8 * BLOCK_SIZE;
            }

            drawBlock(ctx, x, y, color, size = BLOCK_SIZE) {
                ctx.fillStyle = color;
                ctx.fillRect(x * size, y * size, size - 1, size - 1);
                
                // Add some depth with a lighter border
                ctx.strokeStyle = color;
                ctx.strokeRect(x * size, y * size, size - 1, size - 1);
                
                // Placeholder for sprite rendering
                // ctx.drawImage(spriteImage, spriteX, spriteY, spriteWidth, spriteHeight,
                //               x * size, y * size, size, size);
            }

            render(board) {
                // Clear canvas
                this.mainCtx.fillStyle = '#000';
                this.mainCtx.fillRect(0, 0, this.mainCtx.canvas.width, this.mainCtx.canvas.height);
                
                // Draw grid
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (board.grid[y][x]) {
                            const color = COLORS[board.grid[y][x]];
                            this.drawBlock(this.mainCtx, x, y, color);
                        }
                    }
                }
                
                // Draw current piece
                if (board.currentPiece && !board.gameOver) {
                    const blocks = board.currentPiece.getBlocks();
                    for (const block of blocks) {
                        if (block.y >= 0) {
                            this.drawBlock(this.mainCtx, block.x, block.y, board.currentPiece.color);
                        }
                    }
                    
                    // Draw ghost piece
                    this.drawGhost(board);
                }
                
                // Draw next pieces
                this.drawNextPieces(board.nextPieces);
                
                // Update UI
                document.getElementById('score').textContent = board.score;
                document.getElementById('level').textContent = board.level;
                document.getElementById('lines').textContent = board.lines;
                
                // Game over overlay
                if (board.gameOver) {
                    this.mainCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.mainCtx.fillRect(0, 0, this.mainCtx.canvas.width, this.mainCtx.canvas.height);
                    
                    this.mainCtx.fillStyle = '#fff';
                    this.mainCtx.font = '30px Arial';
                    this.mainCtx.textAlign = 'center';
                    this.mainCtx.fillText('GAME OVER', this.mainCtx.canvas.width / 2, this.mainCtx.canvas.height / 2);
                }
            }

            drawGhost(board) {
                if (!board.currentPiece) return;
                
                const ghost = new Tetromino(board.currentPiece.type, board.currentPiece.x, board.currentPiece.y);
                ghost.shape = board.currentPiece.shape;
                
                while (board.isValidPosition(ghost, 0, 1)) {
                    ghost.y++;
                }
                
                const blocks = ghost.getBlocks();
                for (const block of blocks) {
                    if (block.y >= 0) {
                        this.mainCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        this.mainCtx.fillRect(block.x * BLOCK_SIZE, block.y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                    }
                }
            }

            drawNextPieces(nextPieces) {
                this.nextCtx.fillStyle = '#000';
                this.nextCtx.fillRect(0, 0, this.nextCtx.canvas.width, this.nextCtx.canvas.height);
                
                let yOffset = 0;
                for (let i = 0; i < 2 && i < nextPieces.length; i++) {
                    const piece = new Tetromino(nextPieces[i], 0, 0);
                    const blockSize = 25;
                    
                    for (let y = 0; y < piece.shape.length; y++) {
                        for (let x = 0; x < piece.shape[y].length; x++) {
                            if (piece.shape[y][x]) {
                                this.drawBlock(this.nextCtx, x + 0.5, y + yOffset + 0.5, piece.color, blockSize);
                            }
                        }
                    }
                    
                    yOffset += 4;
                }
            }
        }

        // InputHandler class
        class InputHandler {
            constructor(board, canvas) {
                this.board = board;
                this.canvas = canvas;
                this.touchStartX = null;
                this.touchStartY = null;
                this.touchStartTime = null;
                this.lastTapTime = 0;
                
                this.setupKeyboardControls();
                this.setupTouchControls();
            }

            setupKeyboardControls() {
                document.addEventListener('keydown', (e) => {
                    if (this.board.gameOver) return;
                    
                    switch(e.key) {
                        case 'ArrowLeft':
                            this.board.movePiece(-1, 0);
                            break;
                        case 'ArrowRight':
                            this.board.movePiece(1, 0);
                            break;
                        case 'ArrowDown':
                            this.board.dropPiece();
                            this.board.score += 1;
                            break;
                        case 'ArrowUp':
                            this.board.rotatePiece();
                            break;
                        case ' ':
                            this.board.hardDrop();
                            break;
                    }
                });
            }

            setupTouchControls() {
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.touchStartX = touch.clientX;
                    this.touchStartY = touch.clientY;
                    this.touchStartTime = Date.now();
                    
                    // Double tap detection
                    const currentTime = Date.now();
                    if (currentTime - this.lastTapTime < 300) {
                        this.board.hardDrop();
                    }
                    this.lastTapTime = currentTime;
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (this.board.gameOver) return;
                    
                    const touch = e.changedTouches[0];
                    const deltaX = touch.clientX - this.touchStartX;
                    const deltaY = touch.clientY - this.touchStartY;
                    const deltaTime = Date.now() - this.touchStartTime;
                    
                    const minSwipeDistance = 30;
                    const maxTapTime = 200;
                    
                    if (Math.abs(deltaX) < minSwipeDistance && Math.abs(deltaY) < minSwipeDistance && deltaTime < maxTapTime) {
                        // Tap - rotate
                        this.board.rotatePiece();
                    } else if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // Horizontal swipe
                        if (deltaX > minSwipeDistance) {
                            this.board.movePiece(1, 0);
                        } else if (deltaX < -minSwipeDistance) {
                            this.board.movePiece(-1, 0);
                        }
                    } else {
                        // Vertical swipe
                        if (deltaY > minSwipeDistance) {
                            // Swipe down - soft drop
                            this.board.dropPiece();
                            this.board.score += 1;
                        } else if (deltaY < -minSwipeDistance) {
                            // Swipe up - hard drop
                            this.board.hardDrop();
                        }
                    }
                });
            }
        }

        // GameLoop class
        class GameLoop {
            constructor() {
                this.board = new GameBoard();
                this.renderer = new Renderer(
                    document.getElementById('mainCanvas'),
                    document.getElementById('nextPiecesCanvas')
                );
                this.inputHandler = new InputHandler(this.board, document.getElementById('mainCanvas'));
                
                this.lastDropTime = 0;
                this.running = true;
            }

            start() {
                this.gameLoop();
            }

            gameLoop(timestamp = 0) {
                if (!this.running) return;
                
                // Auto drop
                if (timestamp - this.lastDropTime > this.board.getDropSpeed()) {
                    this.board.dropPiece();
                    this.lastDropTime = timestamp;
                }
                
                // Render
                this.renderer.render(this.board);
                
                // Continue loop
                if (!this.board.gameOver) {
                    requestAnimationFrame((t) => this.gameLoop(t));
                }
            }
        }

        // Start the game
        const game = new GameLoop();
        game.start();
    </script>
</body>
</html>