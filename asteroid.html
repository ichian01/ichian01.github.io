<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Asteroids</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: black;
            touch-action: none;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="game"></canvas>
    <script>
        // Vector class for position and velocity
        class Vector {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            add(vector) {
                return new Vector(this.x + vector.x, this.y + vector.y);
            }

            multiply(scalar) {
                return new Vector(this.x * scalar, this.y * scalar);
            }

            static fromAngle(angle, magnitude = 1) {
                return new Vector(
                    Math.cos(angle) * magnitude,
                    Math.sin(angle) * magnitude
                );
            }
        }

        // Base GameObject class
        class GameObject {
            constructor(x, y) {
                this.position = new Vector(x, y);
                this.velocity = new Vector(0, 0);
                this.radius = 0;
            }

            update(canvas) {
                this.position = this.position.add(this.velocity);
                this.wrapPosition(canvas);
            }

            wrapPosition(canvas) {
                this.position.x = (this.position.x + canvas.width) % canvas.width;
                this.position.y = (this.position.y + canvas.height) % canvas.height;
            }

            collidesWith(other) {
                const dx = this.position.x - other.position.x;
                const dy = this.position.y - other.position.y;
                const distance = Math.hypot(dx, dy);
                return distance < this.radius + other.radius;
            }

            draw(ctx) {
                // Override in subclasses
            }
        }

        // Ship class
        class Ship extends GameObject {
            constructor(x, y) {
                super(x, y);
                this.angle = 0;
                this.radius = 15;
            }

            rotate(direction) {
                this.angle += direction * 0.2;
            }

            thrust() {
                const thrust = Vector.fromAngle(this.angle, 0.5);
                this.velocity = this.velocity.add(thrust);
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(this.angle);
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(-10, -10);
                ctx.lineTo(-10, 10);
                ctx.closePath();
                ctx.strokeStyle = "white";
                ctx.stroke();
                ctx.restore();
            }
        }

        // Bullet class
        class Bullet extends GameObject {
            constructor(x, y, angle) {
                super(x, y);
                this.velocity = Vector.fromAngle(angle, 5);
                this.radius = 2;
                this.life = 60;
            }

            update(canvas) {
                super.update(canvas);
                this.life--;
            }

            isAlive() {
                return this.life > 0;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = "white";
                ctx.fill();
            }
        }

        // Asteroid class
        class Asteroid extends GameObject {
            constructor(x, y, size) {
                super(x, y);
                this.radius = size;
                const angle = Math.random() * 2 * Math.PI;
                const speed = Math.random() * 1.5 + 0.5;
                this.velocity = Vector.fromAngle(angle, speed);
            }

            static createRandom(canvas) {
                const size = Math.random() * 30 + 20;
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                return new Asteroid(x, y, size);
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = "gray";
                ctx.stroke();
            }
        }

        // UI Button class
        class Button {
            constructor(x, y, radius, label) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.label = label;
            }

            contains(x, y) {
                const distance = Math.hypot(x - this.x, y - this.y);
                return distance < this.radius;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = "white";
                ctx.fill();
                ctx.fillStyle = "black";
                ctx.font = "bold 16px sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.label, this.x, this.y);
            }
        }

        // Arrow Button class
        class ArrowButton {
            constructor(points, bounds) {
                this.points = points;
                this.bounds = bounds;
            }

            contains(x, y) {
                return x > this.bounds.x1 && x < this.bounds.x2 &&
                    y > this.bounds.y1 && y < this.bounds.y2;
            }

            draw(ctx) {
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.closePath();
                ctx.fill();
            }
        }

        // Game class
        class Game {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext("2d");
                this.ship = null;
                this.bullets = [];
                this.asteroids = [];
                this.isRunning = false;
                this.isGameOver = false;
                this.controls = this.createControls();
                this.init();
            }

            init() {
                this.resizeCanvas();
                window.addEventListener("resize", () => this.resizeCanvas());
                this.canvas.addEventListener("click", (e) => this.handleInput(e));
                this.canvas.addEventListener("touchstart", (e) => {
                    e.preventDefault();
                    this.handleInput(e.touches[0]);
                }, { passive: false });

                this.showStartScreen();
            }

            createControls() {
                return {
                    fire: null,
                    left: null,
                    right: null,
                    update: (W, H) => {
                        this.controls.fire = new Button(W - 60, H - 60, 40, "FIRE");
                        this.controls.left = new ArrowButton([
                            { x: 30, y: H - 60 },
                            { x: 60, y: H - 80 },
                            { x: 60, y: H - 40 }
                        ], { x1: 20, x2: 70, y1: H - 90, y2: H - 30 });
                        this.controls.right = new ArrowButton([
                            { x: 150, y: H - 60 },
                            { x: 120, y: H - 80 },
                            { x: 120, y: H - 40 }
                        ], { x1: 110, x2: 160, y1: H - 90, y2: H - 30 });
                    }
                };
            }

            resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const width = window.innerWidth;
                const height = window.innerHeight;

                this.canvas.width = width * dpr;
                this.canvas.height = height * dpr;
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(dpr, dpr);

                // Update control positions
                this.controls.update(width, height);
            }

            showStartScreen() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = "white";
                this.ctx.font = "30px sans-serif";
                this.ctx.textAlign = "center";
                this.ctx.fillText("Tap to Start", this.canvas.width / 2, this.canvas.height / 2);
            }

            showGameOverScreen() {
                this.ctx.fillStyle = "red";
                this.ctx.font = "40px sans-serif";
                this.ctx.textAlign = "center";
                this.ctx.fillText("Game Over", this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.font = "20px sans-serif";
                this.ctx.fillText("Tap to Restart", this.canvas.width / 2, this.canvas.height / 2 + 30);
            }

            reset() {
                const W = this.canvas.width / (window.devicePixelRatio || 1);
                const H = this.canvas.height / (window.devicePixelRatio || 1);

                this.ship = new Ship(W / 2, H / 2);
                this.bullets = [];
                this.asteroids = [];

                for (let i = 0; i < 5; i++) {
                    this.asteroids.push(Asteroid.createRandom({ width: W, height: H }));
                }

                this.isGameOver = false;
                this.isRunning = true;
                this.gameLoop();
            }

            fireBullet() {
                const bullet = new Bullet(
                    this.ship.position.x,
                    this.ship.position.y,
                    this.ship.angle
                );
                this.bullets.push(bullet);
            }

            handleInput(e) {
                const x = e.clientX || e.x;
                const y = e.clientY || e.y;

                if (!this.isRunning) {
                    this.reset();
                    return;
                }

                // Check controls
                if (this.controls.fire.contains(x, y)) {
                    this.fireBullet();
                } else if (this.controls.left.contains(x, y)) {
                    this.ship.rotate(-1);
                } else if (this.controls.right.contains(x, y)) {
                    this.ship.rotate(1);
                } else {
                    // Thrust
                    this.ship.thrust();
                }
            }

            checkCollisions() {
                // Ship-asteroid collisions
                for (const asteroid of this.asteroids) {
                    if (this.ship.collidesWith(asteroid)) {
                        this.gameOver();
                        return;
                    }
                }

                // Bullet-asteroid collisions
                for (let i = this.asteroids.length - 1; i >= 0; i--) {
                    for (let j = this.bullets.length - 1; j >= 0; j--) {
                        if (this.bullets[j].collidesWith(this.asteroids[i])) {
                            this.asteroids.splice(i, 1);
                            this.bullets.splice(j, 1);
                            break;
                        }
                    }
                }
            }

            gameOver() {
                this.isRunning = false;
                this.isGameOver = true;
                this.showGameOverScreen();
            }

            update() {
                // Update ship
                this.ship.update(this.canvas);

                // Update bullets
                this.bullets = this.bullets.filter(bullet => bullet.isAlive());
                this.bullets.forEach(bullet => bullet.update(this.canvas));

                // Update asteroids
                this.asteroids.forEach(asteroid => asteroid.update(this.canvas));

                // Check collisions
                this.checkCollisions();
            }

            draw() {
                const W = this.canvas.width / (window.devicePixelRatio || 1);
                const H = this.canvas.height / (window.devicePixelRatio || 1);

                this.ctx.clearRect(0, 0, W, H);

                // Draw game objects
                this.ship.draw(this.ctx);
                this.bullets.forEach(bullet => bullet.draw(this.ctx));
                this.asteroids.forEach(asteroid => asteroid.draw(this.ctx));

                // Draw controls
                this.controls.fire.draw(this.ctx);
                this.controls.left.draw(this.ctx);
                this.controls.right.draw(this.ctx);
            }

            gameLoop() {
                if (!this.isRunning) return;

                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Initialize game
        const canvas = document.getElementById("game");
        const game = new Game(canvas);
    </script>
</body>

</html>