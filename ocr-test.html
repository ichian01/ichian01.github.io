<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live OCR</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
    <script src="https://docs.opencv.org/4.x/opencv.js"></script>
    <style>
        body {
            font-family: sans-serif;
            text-align: center;
            padding: 10px;
            font-size: 1.2rem;
        }

        video {
            width: 100%;
            max-width: 480px;
            height: auto;
            object-fit: cover;
            object-position: top center;
            aspect-ratio: 4 / 3;
            border: 1px solid #ccc;
            border-radius: 8px;
        }

        textarea {
            width: 100%;
            height: 140px;
            margin-top: 12px;
            padding: 10px;
            font-size: 1rem;
            border-radius: 6px;
            box-sizing: border-box;
        }

        .buttons {
            margin-top: 12px;
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 20px;
            font-size: 1rem;
            border-radius: 6px;
            border: none;
            background-color: #007BFF;
            color: white;
            cursor: pointer;
        }

        button:hover {
            background-color: #0056b3;
        }

        #canvas {
            display: none;
        }

        #processedCanvas {
            margin-top: 12px;
            border: 1px solid #888;
            border-radius: 6px;
            display: block;
            width: 100%;
            max-width: 480px;
            height: auto;
        }
    </style>
</head>

<body>
    <h1>Live OCR Scanner</h1>
    <video id="video" autoplay playsinline></video>
    <canvas id="canvas" width="480" height="200"></canvas>
    <canvas id="processedCanvas" width="480" height="200"></canvas>
    <textarea id="output" placeholder="Recognized text appears here..."></textarea>
    <div class="buttons">
        <button id="flashBtn">Toggle Flashlight</button>
        <button id="toggleOcrBtn">Start OCR</button>
        <button id="copyBtn">Copy</button>
        <button id="opencvToggleBtn">Use OpenCV: On</button>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const output = document.getElementById('output');
        const toggleOcrBtn = document.getElementById('toggleOcrBtn');
        const copyBtn = document.getElementById('copyBtn');
        const ctx = canvas.getContext('2d');
        const intervalMs = 3000;

        let ocrInterval = null;
        let videoTrack = null;
        let flashOn = false;

        let useOpenCV = true;

        const opencvToggleBtn = document.getElementById('opencvToggleBtn');
        opencvToggleBtn.addEventListener('click', () => {
            useOpenCV = !useOpenCV;
            opencvToggleBtn.textContent = `Use OpenCV: ${useOpenCV ? 'On' : 'Off'}`;
        });


        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                video.srcObject = stream;

                videoTrack = stream.getVideoTracks()[0];
            } catch (err) {
                alert('Camera access denied: ' + err.message);
            }
        }


        async function performOCR() {
            const cropWidth = 480;
            const cropHeight = 200;
            const sx = (video.videoWidth - cropWidth) * 0.25;
            const sy = (video.videoHeight - cropHeight) * 0.50;

            // Draw red crop box overlay
            if (!document.getElementById('cropOverlay')) {
                const scaleX = video.clientWidth / video.videoWidth;
                const scaleY = video.clientHeight / video.videoHeight;
                const overlay = document.createElement('div');
                overlay.id = 'cropOverlay';
                overlay.style.position = 'absolute';
                overlay.style.border = '2px solid red';
                overlay.style.width = `${cropWidth * scaleX}px`;
                overlay.style.height = `${cropHeight * scaleY}px`;
                const rect = video.getBoundingClientRect();
                overlay.style.left = `${sx * scaleX + rect.left}px`;
                overlay.style.top = `${sy * scaleY + rect.top + window.scrollY}px`;
                overlay.style.pointerEvents = 'none';
                overlay.style.zIndex = '10';
                video.parentElement.appendChild(overlay);
            }

            // Draw video frame to canvas
            ctx.drawImage(video, sx, sy, cropWidth, cropHeight, 0, 0, canvas.width, canvas.height);
            await new Promise(resolve => setTimeout(resolve, 50)); // allow drawImage to settle

            if (useOpenCV) {
                const src = cv.imread(canvas);
                let gray = new cv.Mat();
                let dst = new cv.Mat();

                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                cv.adaptiveThreshold(gray, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
                if (dst.cols !== canvas.width || dst.rows !== canvas.height) {
                    cv.resize(dst, dst, new cv.Size(canvas.width, canvas.height));
                }

                // Display processed image
                cv.imshow('processedCanvas', dst);

                // Push to canvas for Tesseract
                const imgData = ctx.createImageData(canvas.width, canvas.height);
                const pixelCount = Math.min(dst.data.length, canvas.width * canvas.height);
                for (let i = 0; i < pixelCount; i++) {
                    const val = dst.data[i];
                    imgData.data[i * 4] = val;
                    imgData.data[i * 4 + 1] = val;
                    imgData.data[i * 4 + 2] = val;
                    imgData.data[i * 4 + 3] = 255;
                }
                ctx.putImageData(imgData, 0, 0);

                src.delete(); gray.delete(); dst.delete();
            } else {
                // Just mirror raw image into processed canvas
                const processedCtx = document.getElementById('processedCanvas').getContext('2d');
                processedCtx.drawImage(canvas, 0, 0);
            }

            // OCR
            const { data: { text } } = await Tesseract.recognize(canvas, 'eng', {
                langPath: 'https://tessdata.projectnaptha.com/4.0.0_best',
            });
            if (text.trim()) {
                output.value = text.trim();
            }
        }


        function toggleOCR() {
            if (ocrInterval) {
                clearInterval(ocrInterval);
                ocrInterval = null;
                toggleOcrBtn.textContent = 'Start OCR';
            } else {
                performOCR();
                ocrInterval = setInterval(performOCR, intervalMs);
                toggleOcrBtn.textContent = 'Stop OCR';
            }
        }

        copyBtn.addEventListener('click', () => {
            const originalText = output.value;
            navigator.clipboard.writeText(originalText)
                .then(() => {
                    output.value = 'Text copied!';
                    setTimeout(() => {
                        output.value = originalText;
                    }, 1500); // restore after 1.5s
                })
                .catch(err => {
                    output.value = 'Copy failed: ' + err;
                });
        });

        document.getElementById('flashBtn').addEventListener('click', async () => {
            if (!videoTrack) return alert('Camera not initialized');

            const capabilities = videoTrack.getCapabilities?.();
            if (!capabilities?.torch) return alert('Flashlight not supported on this device');

            try {
                flashOn = !flashOn;
                await videoTrack.applyConstraints({ advanced: [{ torch: flashOn }] });
            } catch (err) {
                alert('Failed to toggle flashlight: ' + err.message);
            }
        });

        toggleOcrBtn.addEventListener('click', toggleOCR);
        window.onload = startCamera;
    </script>
</body>

</html>